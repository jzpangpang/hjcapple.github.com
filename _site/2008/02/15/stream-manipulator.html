<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="HJC" />
    
    <title>写自己的C++流操纵符</title>
    
    <link href="/atom.xml" rel="alternate" title="HJC Blog" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/main.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link href="http://cdn.bootcss.com/highlight.js/8.0/styles/default.min.css" rel="stylesheet">

    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  </head>
  <body>
      <div id="main" role="main">
        <header>
          <div id="header">
            <h1><a title="HJC Blog" class="" href="/">HJC Blog</a></h1>
          </div>
          <nav>
            
            <span><a title="文章" href="/index.html">文章</a></span>
            
            <span><a title="我" href="/about.html">我</a></span>
            
          </nav>
        </header>
        <div id="content">
        <article>
  <section class="title">
    <h2>写自己的C++流操纵符 </h2>
  </section>

  <section class="meta">

  <span class="tags">
    <p>版权所有，未经许可请勿转载</p>
  </span>

  <span class="time">
    <time datetime="2008-02-15">2008-02-15</time>
  </span>
  
  <span class="tags">
    
  </span>
  
  </section>
  <section class="post">
  <p>学C++，肯定用过操纵符(manipulator)，或者之前没有听过这个名词，也在不知不觉中用过。C++ 标准库中的操纵符有很多，常用的有</p>

<ul>
  <li>std::endl</li>
  <li>std::hex</li>
  <li>std::setw</li>
  <li>std::setfill。</li>
</ul>

<p>有些操纵符没有参数，有些有一或多个参数。没有参数的操纵符包含iostream头文件就可以使用。有参数的操纵符用含头文件iomanip, 这里 io 指 input/output(输入输出), manip是manipulator的头几个字母。</p>

<p>利用操纵符有时可以使程序简单直观。除了利用内部定义好的，我们也可以写自己的操纵符。</p>

<h2 id="section">无参数操纵符</h2>
<p>如何写呢? 首先看看没有参数的。这种操纵符通常可以作为函数来写。比如，我想写操纵符来输出日期和时间，可以这样做。</p>

<pre><code>std::ostream&amp; time(std::ostream&amp; ostr)
{
    time_t curtime;
    time(&amp;curtime);
    tm* ptime = localtime(&amp;curtime);

    ostr &lt;&lt; ptime-&gt;tm_hour &lt;&lt; ':' &lt;&lt; ptime-&gt;tm_min &lt;&lt; ':' &lt;&lt; ptime-&gt;tm_sec;
    return ostr;
}

std::ostream&amp; date(std::ostream&amp; ostr)
{
    time_t curtime;
    time(&amp;curtime);
    tm* ptime = localtime(&amp;curtime);

    ostr &lt;&lt; (ptime-&gt;tm_year + 1900) &lt;&lt; '-' &lt;&lt; (ptime-&gt;tm_mon + 1) &lt;&lt; '-'
         &lt;&lt; ptime-&gt;tm_mday****;
    return ostr;
}
</code></pre>

<p>之后就可以用了，用法和 std::endl 一样。</p>

<pre><code>int main()
{
    std::cout &lt;&lt; date &lt;&lt; std::endl;
    std::cout &lt;&lt; time &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>time 和 date 可以作为输出使用，如果你写的操纵符要作为输入，函数原形相应为</p>

<pre><code>std::istream&amp; fun_name(std::istream&amp; istr)
</code></pre>

<p>如果可以用作输出输入，可以写为</p>

<pre><code>std::ios&amp; fun_name(std::ios&amp; iostr);
</code></pre>

<p>为什么写成这样就可以用的呢? 我以输出为例说一下。
C++库里面有个函数为</p>

<pre><code>std::ostream&amp; operator &lt;&lt; (std::ostream&amp; ostr,
                           std::ostream&amp; (*pf)(std::ostream&amp;);
</code></pre>

<p>pf为函数指针，注意指针类型和我们写的 time 和 date 一样。它的实现可以简单的为 return pf(ostr);。</p>

<p>这样，我们写 <code>std::cout &lt;&lt; date</code> 就调用了</p>

<pre><code> operator &lt;&lt; (std::cout, date)
</code></pre>

<p>跟着转为 <code>date(cout)</code>, 因为返回值为 <code>std::cout</code>, 可以和 <code>std::endl</code> 连用。</p>

<h2 id="section-1">有参数操纵符</h2>
<p>再来看看有参数的操纵符，这个不能作为函数来写。举个例子, 我想有个操纵符来将某个字符c重复n次，repeat(char c, int n), 当n为负或0时无效。可以这样做。</p>

<pre><code>class repeat
{
public:
    repeat(char c, int n) : _c(c), _n(n)
    {
    }
    
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const repeat&amp; r)
    {
        for (int i = 0; i &lt; r._n; i++)
        {
            ostr &lt;&lt; r._c;
        }
        return ostr;
    }
    
private:
    char _c;
    int _n;
};
</code></pre>

<p>之后可以这样使用</p>

<pre><code>int main()
{
    std::cout &lt;&lt; repeat('#', 13) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>这个其实也很简单，<code>repeat('#', 13)</code> 创建了一个临时的对象tmp, 类型为repeat, 跟着调用 std::cout«tmp, 也就是调用</p>

<pre><code>operator &lt;&lt; (std::cout, tmp)
</code></pre>

<p>也就是创建了一个可流的对象。有个地方要注意，</p>

<pre><code>friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; ostr, const repeat&amp; r)
</code></pre>

<p>中的const不能去掉，不然就不能创建临时对象了。</p>

<h2 id="section-2">注</h2>
<ol>
  <li>
    <p>C++ 标准库其实没有一个叫 std::ostream 的类，只有个 std::basic_ostream，std::ostream只是其 typedef 定义出来的。std::basic_ostream是个模板类。</p>
  </li>
  <li>
    <p>localtime 函数返回的 tm 结构，字段 tm_year 并不是真实年份，而是真实年份减去1900年，tm_mon取值为0-11, 所以要算出年和月用相应加上1900和1。</p>
  </li>
  <li>
    <p>operator « 为左结合，当写 </p>

    <pre><code> std::cout &lt;&lt; date &lt;&lt; std::endl;  其实为

 ((std::cout &lt;&lt; date) &lt;&lt; std::endl);  `std::cout &lt;&lt; date` 返回`std::cout`, 跟着再执行`std::cout &lt;&lt; std::endl;`&lt;br&gt; 这就解释了为什么我们写函数 operator &lt;&lt; 的时候为什么返回值一为`std::ostream&amp;`, 这是为了可以连续输出。
</code></pre>
  </li>
</ol>


  </section>
  
</article>

        </div>
        <footer>
          <div>
            
            &copy; 2006 ~ 2014 HJC | powered by jekyll | themed by <a href="http://lhzhang.com" title="sext vi">sext vi</a> | <a href="https://github.com/hjcapple/hjcapple.github.com" title="fork me">fork me</a>
          </div>
        </footer>
      </div> <!-- main -->

      <script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
      <script >hljs.initHighlightingOnLoad();</script>
  </body>
</html>
