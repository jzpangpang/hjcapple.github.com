---
title: 理解C++ — 变量与常量(1)
layout: post
published: true

---
## 内存属性

程序运行时，所用的数据被放在内存。内存有两个最基本的属性:

* 它的地址(编号)
* 它存储的数据。

如同一堆小箱子，编号用来区分到底用到哪个箱子，数据就如箱子里面放着的东西。

数据放在内存，我们给它一个名字。名字只不过是个符号，符号本身都是没有什么意义的，符号代表的东西才有意义。根据名字可以方便取回自己定义的数据。名字到最后被翻译到地址。可以说，名字是给人看的，地址编号是让机器看的。那个人可能是别人，更可能就是自己，请花点心思去取个好名字。

## 变量与常量

数据放在内存之后，可分为变量与常量。常，指不变；量，指数值。

前面已提到，内存有地址和存储的数据两个最基本的属性。同样常量与变量也有两个最基本的属性。

* 它分配到的内存地址，
* 地址所指内存里面的数值。

常量与变量就是从地址所标内存里面的数值可否变化来区分的。程序执行时数值可变为变量，不可变为常量。常量的数值在程序执行之前已经确定下来的了。

当然变量与常量还有其它的要素，比如名字和类型。名字最终翻译到地址，类型决定它们的占有内存的大小和拥有的行为。


## static，dynamic，auto

从内存里面的数值是否可变可以区分变量与常量。而从分配的内存地址的角度来看，又可以将变量与常量分为三种不相同的状态:

* 静态(static)
* 动态(dynamic)
* 自动(auto)

在C++中，关键字const含义为不变(常), 关键字static含义为固定(静)。

照我理解（注意，是我自己的理解)，常和静，变和动，都是一个意思，指变化和不变化，只不过常和变是对于内存存储的数而言，静和动是对于内存地址而言。

现在看看静态，动态，和自动到底是什么含义，怎么去区分? 

### 静态分配
当程序刚启动，系统会分配些栈啊，程序控制块啊，各个段啊之类，这可以算一个准备阶段，在这个准备阶段，程序代码还没有正式执行，常量与常量所需的内存已经分配好了，地址已经确定下来，这就为静态。

### 动态或自动分配
当程序代码已经执行，才去分配内存，内存地址还没有确定，为动态或者自动。要是代码正在执行，需要内存分配，这一个分配行为由系统全部完成，不用你去操心，就为自动；要是需要程序员自己决定分配的时机，显式调用malloc，new 之类的分配函数，就为动态。概括的说，程序执行之前已经分配好内存，决定好内存地址，为静态; 程序执行之时再分配，分两种情况，

* 系统自动完成，为自动类型。
* 需要显式调用分配函数，自己决定时机，为动态。

### 绑定
将属性关联到数据的过程，叫做绑定(binding)。如果在程序执行之前，变量与常量的属性已经确定了，就叫静态绑定；要是要等到程序执行之时，属性才被关联，被确定，就叫动态绑定。

看看C++的书籍，静态，动态，绑定的概念会老是出现的, 到这里应该有大概的理解了，主要是以属性确立的时机来区分。

其实不单是变量，常量，有时候调用什么函数(也就是函数的地址)也需要在程序执行之时才能确定。这时候可以先将函数地址先存起来，或者做成一个表。怎么函数地址也可以放起来的吗? 当然可以了。函数也需要内存来放，也有地址。对于计算机来说，所有东西都是101010之类的数值，什么都已经没有区别了。函数，代码，浮点，对象，跟int之类的整型没有什么两样。


## const关键字

### const约束
C++中，const是个很重要的关键字，施加了一种约束。有约束其实不是件坏事情，无穷的权利意味着无穷的灾难。应用了const之后，就不可以随便改变变量的数值了，不小心改变了编译器会报错，就容易找到错误的地方。编译时期找到的错误越多，隐藏着的错误就会越少。只要你觉得有不变的地方，就用const来修饰吧。

* 比如想求圆的周长，需要用到Pi, Pi不会变的，加const，const double Pi = 3.1415926;
* 比如需要在函数中传引用，只读，不会变的，前面加const; 
* 比如函数有个返回值，返回值是个引用，只读，不会变的，前面加const; 
* 比如类中有个private数据，外界要以函数方式读取，不会变的，加const，这个时候就是加在函数定义末尾。

加在末尾只不过是个语法问题。其实语法问题不用太过注重，语法只不过是末节，接触多了，自然记得，主要是一些概念难以理解。

### const 修饰指针
const修饰指针就需要注意一下了。要是修饰的类型不是指针，比如int之类，const放在int之前和int之后是一样的，比如

	const int a = 2;
	int const a = 2;
		
有着同样的效果。

当类型为指针时，以星号\*为界, const加在左右两边，有不同的意思。

	1. const int* pa = &a; \\ 也可以写成 int const* pa = &a; 注意是以星号为界
	2. int* const pa = &a;

写法1表示pa所指向的变量，也就是a的值不可变。写法2表示pa的指向，也就是pa本身的值不可以变，不可以现在指向a, 跟着指向b。

例子1.

	int a = 2;
	int b = 3;
	const int* pt = &a;
	//*pa = 1;            Error
	pa = &b;              OK  
			
例子2

	int a = 2;
	int b = 3;
	int* const pt = &a;
	*pa = 1;             OK
	//pa = &b;           Error   


### 例子分析
前面已经说过了，const用来指示内存中的数值不会变。指针本质上是一个地址(编号), 这个编号也需要放在内存。所以pa这个变量放在内存，数值是一个地址。

* 当const在\*右边，const直接修饰pa, 表示pa的数值不会变，所以也就不可以改变指向。

* 当const在\*左边，就修饰指向的变量，故\*pa的值不能变。

要是写成`const int* const pa = &a;` a的值不可变，pa的指向也不可变。

[下接变量与常量(2)](/2007/07/08/cpp-const-2.html)



