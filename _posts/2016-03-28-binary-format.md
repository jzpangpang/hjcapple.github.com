---
title: 二进制格式设计
layout: post
published: false
---

有些时候我们需要设计自己程序的文件格式。比如一个矢量绘图程序，需要记录下用户绘图的每一条线。应该优先考虑文本格式，文本格式容易测试并且编辑容易。也应该先考虑使用通用的文本格式，比如 XML, JSON, Lua 之类。通用的文本格式已经存在大量的可用工具，读入时候的解释器也不用自己来编写，省下很多功夫。

不过文本格式读取时候有点慢，并且文件尺寸也比较大，但这通常不是什么问题。但在一些需要更高读取性能，更小文件尺寸的场合，就需要设计二进制文件格式。

本文就描述二进制文件格式常见的设计思路。

## 整体文件结构
常见二进制文件格式，整体上通常采用 文件头 + 分区 的方式，很少有例外。比如

	Header 
	分区 1
	分区 2
	分区 3
	分区 4
	....
	分区 N
	
文件头，描述了文件的整体信息。常见的字段有文件大小，版本号，魔数，检验码等等。文件头根据文件的用途，会有额外的字段，比如一张图片，文件头当中就可以包含图片的大小。

分区的结构通常会是：

	tag
	length
	data
	
最开始是 tag + length，之后就是分区的具体数据。

这个 tag 可以是一个整数，也可以是一个字符串。tag 用来标识各种不同的分区。

比如
	
	#define kTextTag    1
	#define kCodeTag    2
	#define kStaticTag	3
	
或者

	#define kTextTag   "text"
	#define kCodeTag   "code"
	#define kStaticTag "stat"
	
tag + length 合起来就是分区的头部。length 是个整数，表示分区数据的具体长度（不包括分区头部），或者表示整个分区的长度（包括分区头部）。

采用这种分区结构，使得文件格式容易扩展，有新需求时就定义一个新的分区类型，原来的文件结构不需要修改。也容易向上兼容，比如一个程序 1.0 已经发布出去了，支持文件格式 1.0；而程序 1.2 有了新功能，就定义了一种新的分区类型，文件格式为 1.1。这样程序 1.0 也可以读取 1.1 格式，只是遇到不认识的分区类型就直接忽略掉，这样虽然不支持新功能，但至少还是可用的。

注意程序的版本号，跟文件格式的版本号可以是不对应的。比如上例中，程序版本是 1.2，但文件格式还只是 1.1。

有些时候，分区数据本身，再细分，再次采用这种分区的结构。比如一个矢量绘图程序，需要记录下图元。可以设计成：

	绘图 Header
	绘图分区
	预览图分区
	
绘图分区再划分成具体的图元分区，仍然采用 tag + length 的结构。

	#define kPicCircle	1
	#define kPicRect  	2
	#define kPicBezier	3
	
这样就可以不断地增加各种图元。

## 文件头结构

	

	

	
	





	

	

	




