---
title: 双人贪食蛇的思路（上）
layout: post
published: true
---
## 注
这篇文章是很早期的了，有些代码风格，我已经抛弃了。

暑假的时候我写了个贪食蛇的小程序，觉得效果还可以，现在将思路简单的说一下。很多人都对这个经典的游戏有兴趣的，我刚开始学编程的时候也是立志自己写一个，这个目标也算是完成了。

## 状态表示
首先要解决的一个问题是如何来描述蛇的状态。

蛇总是在一些小方格上面爬行的，假如横数有`cxNumberOfRect`个小格，竖数有`cyNumberOfRect`个，就共有`cxNumberOfRect * cyNumberOfRect`个小格。对于每一个小格，经过简单的影射，可以用一个`POINT`来表示，也可以用一个二维数组的一个元素来表示。蛇身是由一系列的方格来组成的，自然也可以用一系列的点，或者一个二维数组来描述。

先看第一个方法，就是用一系列的点来表示。其实不用组成蛇身的每个点都记录下来(点对应了方格)，只要记录下关键的点就可以的了。什么点关键的呢？自然是头、尾、和全部拐弯点。光知道这些关键点还不够，蛇爬行的时候还有一定的方向，尾所在的点也有一定的方向。在尾遇到拐弯点的时候，方向也要改变，所以拐弯点也要有一定的方向，不然尾就不知道转向哪里了。这时候，就知道，应该要有一个结构来记录每个点的状态，一个元素是坐标，可以是`POINT`类型，一个用来记录方向，可以是`UINT`类型，我自己是这样定义的

``` C++
#define	DS_UP     0x0001
#define	DS_DOWN   0x0002
#define	DS_LEFT   0x0003
#define	DS_RIGHT  0x0004

struct SNAKE_TURNING_POINT
{
    POINT    ptTurning;  //拐点坐标
    UINT    Direction;  //拐弯方向
};
```
	
那几个`#define`语句是让数值直观，这是宏的重要用法，当然也可以用`const`定义一些常量。

再接着分析，当蛇要转弯的时候，头的方向就会改变，这个时候就会产生一个拐弯点，当尾遇到一个拐弯点的时候，尾的方向就改变，那个拐弯点就不存在了。简单分析就知道，最先产生的拐弯点，也最先消失，这时候就好自然地想到用一个队列来储存拐弯点了。所以我们的`CSnake`类中就应该有个 

``` C++
queue<SNAKE_TURNING_POINT> m_qTurning; 
```
	
名称自然可以改成其他的。可能会想，蛇头和蛇尾也用这个队列储存起来行不行呢? 不行的。因为头，尾每时每刻都会变，自然每时每刻都用修改，你放在队列中，就不可以随时取出来。这个时候，自然`CSnake`中也会有变量

``` C++
SNAKE_TURNING_POINT    m_Head; 
SNAKE_TURNING_POINT    m_Rear; 
```	

根据这个队列和这两个变量，就可以知道蛇的状态，也可以好容易的修改蛇的状态。

现在看第二种方法，用二维数组。大家都应该想到的了，就是定义一个

	bool m_State[cxNumberOfRect][cyNumberOfRect];
	
数组元素中为1表示蛇占了这个方格(数组元素对应了方格)，为0表示没有占用。用数组直观，不过有个最大的缺点，就是修改蛇的状态时候，会非常之困难，要历遍整个数组，做很多个判断，而每时每刻蛇的状态都要改变，整个程序的效率就会很差。在我自己的`CSnake`类也有这样的二维数组，主要是用来判断死亡的情况，还要产生新的豆的坐标(我叫豆的，可能有些人叫青蛙之类)，其实也可以不用数组的，只是这时候，判断起来要难点。判断死亡条件后面会慢慢说到的。

## 拐弯前进
有了上面的结构，和队列，实现转左，转右，转上，转下的功能就好简单了，这时只不过是简单修改头的方向，跟着将头`m_Head`放到队列中就可以了，因为转弯时候，这个点也成为拐弯点。

蛇前进的功能也不难。先看`m_Head`的变化，我们已经知道了方向，知道了原来的坐标，就自然好容易的知道前进之后的坐标，而方向是不变的。考虑尾，也就是`m_Rear`的变化，也容易得到新的坐标点，不过方向就要考虑队列的最前面的元素的，要是这个时候尾的坐标和这个元素的坐标相同，说明尾部要拐弯了，尾的方向也要改变了。这时候，原来的拐点也不再成为拐点了，就从队列中弹出，其他情况下尾的方向也不会改变。

## 吃豆功能
吃豆功能只不过是将尾部的坐标修改成之前的坐标就可以了，也不难。你想想头坐标不变，尾坐标改成之前的，蛇就加长了。当蛇头坐标等于豆的坐标的时候就调用这个功能。

## 死亡条件

跟着就要考虑死亡条件了，碰到自己的身体就会死亡。蛇每前进一步都做出判断，我前面说过定义了一个`bool`类型的数组，这个时候就发挥了作用，这时候就看看头所在的坐标对应的数组元素，要是为1表示蛇已经占用了这个格子，就死亡了。知道坐标，再访问数组是好容易的，方格，坐标，数组元素都存在一一对应的关系。自然这个时候，每前进一步也要修改数组的值，只是简单的将新头部对应的元素变1，旧尾部对应的元素变0就可以了。死亡的时候还要判断边界，碰墙壁也会死亡，可以用>，<边界值来判断。其实也可以采用另一种方法，就将我们的数组加大，就好象在四周围了栏杆，将靠边的元素初始为1，这个时候几个判断，就会变成一个判断。相应地，我们的数组应该定义成

	bool m_State[cxNumberOfRect+2][cyNumberOfRect+2];
	
这样的小程序多用一点空间也没有什么所谓。

## 产生新的豆坐标

吃豆之后要产生新的豆坐标，豆的坐标不能够产生在蛇的身上。这时候我们的二维数组又要用到了，因为数组记录了蛇占用的格子。

豆的坐标要有随机性，用线性同余来产生随机数，至于随机数的产生原理，不在本文的讨论范围。

好多人会想到先产生x坐标，再产生y坐标，要是那个坐标对应的数组元素已经为1了，就再产生一次，一直到那个元素为0为止。我开始的时候也是这样想的。不过这样有个问题，要是蛇已经很长，很多数组元素的值为1了，就要尝试很多次，要是总共能有1000个格子，蛇已经占了500个格子，就要碰运气了。

我是这样做的，先产生从0到空格数目(没有被蛇占用的格子数)之间的随机数，假设为X，跟着从第一个空格开始数，数到第X个空格，那个空格就是新的豆所在的方格，格子和坐标对应，就可以得到豆的坐标，这样的简单算法总是可以得到坐标的，就算是蛇已经很长了，效率也不会降低到不可忍受的地方，也不靠碰运气。

写程序的时候切忌让程序碰运气，要尽你可能考虑出每种可能发生的情况并做出相应处理，就算是发生的几率很少。不要认为很少发生就让它就这样过去，要是你这样做，你的程序就会有缺陷。当然有缺陷是很难避免的，不过要尽可能的使缺陷减少到最低。

## 双人贪吃蛇规则

对于单人游戏的贪食蛇，规则是怎么样的就不用介绍了。那双人游戏怎么玩啊？我是这样设规则的。玩家一和玩家二都可以吃和自己颜色相同的豆，所以屏幕上会有两种颜色的豆。当其中一个人吃了豆之后，对方会加长，就是调用对方的`EatBean`函数，跟着两人豆的位置就重新改变，调用`CalBeanPos`函数。

那个人先死就输，而不是看那个吃的豆多。假设Player1吃了100个豆，Player2吃了1个豆，要是Player1先死，也是Player1输，要是同时死亡，就平局，也不看吃豆的多少。容易知道，贪食蛇中越长越容易死亡，可以说吃豆是使对方先死的手段而不是目的。

我觉得这样设定规则也算是合理的。当然不同的人想法也不同。两人在屏幕上玩的时候，各人有各人的颜色，要是交叉重叠，重叠的地方就显示成叠加后的颜色，和两人的颜色都不同，离开的时候再恢复。所以看起来会有一条蛇在另一条蛇身上穿行的效果。

上篇就写到这里，主要讲的是如何描述蛇的状态和行为，对于不同的语言，不同的系统，其中的思想都适用。本文的下篇就主要讲蛇的画法，也就是在Windows下，屏幕上面显示。

 