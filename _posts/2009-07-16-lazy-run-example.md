---
title: '延迟执行的一个例子'
layout: post
guid: urn:uuid:e066c88b-9c82-44ad-b47e-ded1550ab433
tags:
    - C++
---


问题
-------
相信大家多多少少都有拖延的毛病。比如要你收拾屋子，就可能会拖上两个星期，等自己习惯了，就不觉得乱了。当然上面说的那种拖拉是不好，但适当的懒惰是人们前进的动力。程序设计中有些技术就用到了拖延战术。如写时复制等。

假如有个类，构造函数的开销很大，需要全局访问，又不一定需要用到。你会怎样做？将这个类暂时定名为BigClass。一个例子就是打印错误信息的类，可能没有出错，就没有必要使用。

方案1
-----
你直接定义 

		BigClass myClass;
		
这样BigClass的构造函数一开始就被调用了，如果没有用到这类，构造函数是浪费了。

方案2
-----
定义一个指针。

		BigClass* pClass = NULL; 

真正需要用到再判断指针，再new或用工厂方式构造出来。
这方案是不错的，大部份情况也可以了。但new需要内存，如果内存不足，new返回错误怎么办。比如那个打印错误信息的类，如果内存不足，需要这个类来打印错误。但new这个类出来的时候又出现内存不足，这个类构造不出来。

 
方案3
---------
定一个函数。比如

		BigClass* getBigClass()
		{
		 	static BigClass myclass;
		 	return &myclass;
		}
		
这个方案，可以摆脱那个new分配内存的问题。因为myclass已经在_BSS段有空间了。妙的是第一次调用getBigClass()函数的时候，BigClass的构造函数才会执行，这样就可以省下没有必要的构造函数调用。每次拿指针都要调用一个函数，可能有些人觉得不方便。


方案4
---------
定义一个指针，跟一个数组。

		char classBuff[sizeof(BigClass)];
		BigClass* pClass = NULL;
		
需要的时候，调用 

		pClass = new(classBuff) BigClass. 
		
这是placement new的一种用法。这方案预先分配好内存，并避免过早调用构造函数。这写法对于不了解placement new的人来说比较怪异。


总结
---------
其实不一定说那种方案好，根据不同的时候可以采用不同的做法。很多所谓的方案，原则都是死的，人是活的。比如原则，如果你不了解为什么要定这原则，那你最好遵守。但如果你很明白那原则为什么要这样，看透了它的优点跟不足，那你根据情况可以适当违反。