---
title: 双人贪食蛇的思路（下）
layout: post
published: true

---

跟着要说显示的问题了，虽然的前面说的已经可以描述蛇的行为和状态了，不过要在屏幕上显示出来也要有点技巧。在Windows中有个函数是`Rectangle`，是画矩形的，蛇身可以用这个函数画出来，因为蛇身是由方格，也就是矩形组成的。知道坐标，对应成方格，对应成矩形，跟着调用函数就可以了。

那是不是每一次蛇前进的时候都要将组成蛇身的矩形都画一次呢？其实不用的，蛇行走的时候，改变的只不过是头和尾，就是画出新的头，去掉原来的尾，由于视觉停留，看起来蛇就会动了，这样做效率会比较高，因为只要重画两个矩形，也不会有一闪一闪的现象。

另外，要是将窗口拖出屏幕，看不见了，就要将整个蛇身重新画一次，这种画法也不要采用判断整个数组的元素的值为1就画，为0就不画的方法。因为数组是比较大的，判断起来也费工夫，可以将队列的元素复制到另一个队列，加上头和尾，得到关键的点，就画两个关键点的之间所有方格就可以了，他们总是水平或者是垂直的。具体实现起来也不难，就不多说。本文是讲思路而不是讲具体实现的，不然篇幅会更长。

那怎么画头去尾呢? 假设蛇是红色的，背景是白色的，好多人大概都会想是选红的画刷，画头，跟着选白的画刷，画尾，因为尾的颜色和背景颜色一样，就看不到了。这样想本来是没有错误的，也是最自然的想法，对于单人的贪食蛇游戏就可以了。不过就如本文标题说的，我们要写的是双人玩的贪食蛇，这样做就会产生问题。双人玩的时候，自然会产生两个CSnake类，在屏幕上要产生两条蛇，蛇身要用不同的颜色来区分，当不互相碰撞的时候，显示不会有问题。当相碰的时候，就会有叠加的方格，这些方格要显示什么的颜色呢？当然要是产生和玩家1，玩家2的颜色都不同的颜色就最好，就算和其中之一相同也没有什么大错。真正的问题是，按照前面做法，当一条蛇和另一条蛇相碰并离开的时候，或者一条蛇在另一条蛇身上穿行的时候，因为去尾是刷成白色，就会令到其中一条蛇，有的时候甚至是两条蛇都会出现断裂，也就是一边是红色了，另一边也是红色，中间却没有了，因为变成了背景色，也就是白色了。这样显示出来会很难看。

对于相碰显示的问题，也可以避开它，可以设计成碰到对方的身体也会死亡的(这个时候玩起来要更加小心，我觉得也会小点乐趣)也可以不避开它，而采用判断，当判断得出重叠时候显示另一种颜色，离开时候再判断，恢复成恰当的颜色。两种做法都要得到对方的状态，也就是说CSnake中必须有些Static的成员数据，或者是有可以得到状态的函数。做判断的也会很复杂，不利于CSnake类的封装。在考虑更极端的情况，要是我不是两个人玩，我是要四个人一起玩，这种写法会令你发狂，根本不利于程序功能的扩充。

那要如何解决呢？在Windows画图的函数中，有个函数是`SetROP2`，可以设置光栅操作，平时默认的是`R2_COPYPEN`，设置这个状态的时候，画图函数的颜色就是画笔或者画刷的颜色。要是设置成`R2_NOTXORPEN`，有个特殊的用法，这时候用画图函数画一次，出现图象，再用原来的函数，在原来的地方再画一次，就又变成原先屏幕上的颜色，原先是红就是红，原先是绿就是绿。`R2_NOTXORPEN`的光栅操作是 not(像素 xor 画笔)，这里像素是原先屏幕颜色，画笔不单是画笔也是画刷的颜色，运算的结果就是新的屏幕颜色。(颜色在计算机里面也是用0和1来表示的，所谓的运算是位运算)。 让我们简单分析一下为什么用这种运算下画两次可以恢复原来屏幕的颜色。用A表示屏幕像素，B表示画笔，画一次屏幕像素为!(A xor B) 再画一次是屏幕像素就是!( !(A xor B) xor B)化简这个式子，也可以用真值表来判断得到 A，也就是原先的屏幕颜色了。因为我们的开始时候的背景色是白色的，颜色对应的数值都为1，看看!(1 xor B)会为B，也就是说在背景色为白色的情况之下，画一次会是画刷的颜色，画两次就恢复成背景色。用这种光栅操作之下，就不用考虑对方的状态，要是相交的时候，颜色也会叠加，产生一种新的颜色了，离开的时候也会自动恢复。

上面那段话可能有点费解，可以参考SetROP2函数的用法和一些关于颜色，光栅的基本知识，不再多说了。所以现在我们需要画头的时候，是在这种光栅操作下调用Rectangle，需要去掉尾部时候，也就选取同样的刷子在原先尾部的位置上调用Rectangle。这样做就不再需要考虑各个玩家的状态了，要是写四个人一起玩也是一样的，颜色也自然会叠加。 只不过没有这样多的键盘位置。这时候要是懂一点网络知识的话完全可以写出一个多人联网玩的贪食蛇游戏。我相信不久会也会有些公司会开发出这样的游戏，就好象四国军旗一样，分成两队比赛。

本篇最初开始的时候说了画蛇应该有两种画法，一种是画头去尾，一种是整个蛇身全部重画一次，定为成员函数

	void  DrawA(HDC hdc);    //画头去尾
	void  DrawB(HDC hdc);    //全部重画一次

那什么时候要调用那一个呢？知道DrawA的效率会很高，正常情况下就是调用这个画法，就是响应WM_TIMER消息时候。当窗口拖出屏幕，再拖回来，或者最小化跟着恢复就需要调用DrawB，实现的时候，可以定义一个标志值做出判断，采用不同的画法。 要是老是用DrawB，屏幕会很有闪烁的。

看到这里，相信有人就知道这个游戏应该怎么写出来的了。

我自己的程序中，还有两个功能是可以选择穿墙，可以选择向后退。穿墙就容易啦，就是在前面分析的基础上，当头的坐标已经碰到一边的墙了，就将它坐标设置成另一边的，尾也一样，自然就会穿过墙壁了。穿墙和不穿墙可以设置一个标志值判断，程序在响应菜单选择时候，就修改这个标志值。至于后退，要难点。你拿个笔来画一下，就会发现头和尾的坐标要改变，拐弯点在队列中位置也正好相反，方向和原来的方向也会有一定的相反的位置关系，对于反转元素的位置，自然容易借助于一个堆栈来实现。看看，那些“没有用”的数据结构又发挥作用了。

整个构思简单回顾一下，蛇的很多行为都是建立在一个队列和头，尾状态的基础之上的，只要改变这些值，蛇就会呈现不同的状态和行为。自然也要用到那个二维数组，其实它不是必要的，通过一些手段，可以将它去掉，就可以省去不少空间，只是实现起来也麻烦一点。对于个人计算机这点空间不算什么，要是对于内存紧张的情况，比如搬到手机上时，就要重新考虑。

这里还有一个细节问题。通常对于这样的有动画效果的程序，都会设置一个定时器，经过一定的时候发送一个`WM_TIMER`消息。在我自己的程序在也有`WM_TIMER`消息，主要是调用`GoAhead`(向前走)，这个是好显然的，另外还要处理键盘按键，主要是调用
	
	TurnUp(转上）
	TurnDown（转下） 
	TurnLeft（转左）
	TurnRight（转右）

来改变方向。 这时候处理`WM_TIMER`和`WM_KEYBOARD`的时候就要注意了。 因为`WM_TIMER`是要隔一定时间才能处理的（因为这个消息是隔一定时间才发送的），键盘却可以随时按，要是按键很快的时候，好可能在再处理一次`WM_TIMER`期间，已经产生了不止一次的`WM_KEYBOARD`消息，要是每个`WM_KEYBOARD`都让蛇转弯，在`WM_TIMER`消息处理中还没有调用`GoAhead`的情况下，考虑我们前面队列的实现方法，就相当于在同一坐标中放了好多拐弯点进队列。 这时候当然程序就会出错。 开始我写这个程序的时候，就是出现这样的问题，让我找了一个下午。 所以我再定义了一个标志值`F_ENABLEPLAYER1`，在每次处理完`WM_TIMER`消息后将标志值设置为1，在每次处理完`WM_KEYBOARD`消息后将标志值设置为0，在标志值为0的情况下，将`WM_KEYBOARD`消息丢弃，不做转弯处理，这样之后，问题就解决了。 这个也应该算是同步问题吧。 在双人游戏下，可以再设置一个`F_ENABLEPLAYER2`，原理同上。速度选项只不过是修改定时器的设置，让它发送消息的时间间隔改变就可以了。

程序中可以两个`CSnake`类型的指针，Player1和Player2，初始为`NULL`。程序刚运行的时候就用Player1 new出一个类。当选择双人游戏的时候，Player2也new 出一个类，再选择单人的时候就`delete Player2`，跟着Player2重新设置成NULL，这样就可以用Player2是否等于`NULL`，来判断出是否双人游戏，来做出各自的处理了。

至于我自己程序的其它一点小功能，好象声音，颜色，语言之类，只不过是设置相应的数值和标志值，在进行进行判断，只要花点时间，花点耐心去做，就自然可以写出来。 也没有什么好说的。


 