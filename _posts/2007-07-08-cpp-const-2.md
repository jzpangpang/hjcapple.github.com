---
title: 理解C++ — 变量与常量(2)
layout: post
published: true

---
 [上接变量与常量(1)](/2007/07/07/cpp-const-1.html)
 
const_cast
-----------
前面说过, const 这个关键字可以施加一种约束，使得不会错改内存的值。要是真的想改变那个值，可以通过const_cast 转型。比如：

```C++
int a = 2;
const int* pa = &a;
//*pa = 100;                  Error
*const_cast<int*>(pa) = 100; //OK
```

`*pa = 100` 编译错误是因为我们用 const 施加一种约束。而 const_cast 转型符将const约束取消掉，故

```C++
*const_cast<int*>(pa) = 100
```
		
可以编译通过。const_cast 能够用在指针和引用类型。

设计理念
----------
这样一个转型符，给程序员更大的自由。C++ 的一个设计理念是信任程序员，它假设程序员知道自己在干什么。当写出

```C++
int a = 2;
const int* pa = &a;
*pa = 100;
```

的时候，可能是不小心。但是当写出

```C++
int a = 2;
const int* pa = &a;
*const_cast<int*>(pa) = 100;
```

的时候就代表清楚自己想做什么了。

C++ 是自由的，但是为了享受这份自由，前期需经历磨难。以学自行车为例，C++ 如同放开双手，让你自己去骑，开头会跌得很惨，之后可灵活拐向任何地方。而有些语言就如同在车子后面安装两个小轮子，会很安全，但想骑快或想拐进窄巷，那小轮子就是累赘。


内存布局
-----------
那些常量变量，静态动态，是怎么在内存是怎么存放的呢?

### 分区
我们知道，数据有不同的性质，有些可读不可写，有些可读可写，有些只可以给系统读写......等等。这样不同性质的数据就分开放到内存不同的位置，这叫分段或者叫分区。

分段之后最大的好处是容易实现保护。可以指定从开始到结束，这个范围的内存空间的性质，假设是分区只读的，程序执行的时候意图修改，就会触发错误处理。

我们经常会将空指针赋值为 0, 低端地址通常为系统保留，不可被访问，当想引用地址 0 中的数据，就会引发错误。

###windows程序执行时的典型内存分区
     
     高地址  +-----------+
            |           | (未初始化)变量
            +-----------+
            |           | 静态变量
            +-----------+
            |           | 只读
            +-----------+ 
            |           | 常量(不可访问)
            +-----------+
            |           | 代码 
            +-----------+  
            |           | 堆 
            +-----------+  
            |           | 栈  
            +-----------+  
            |           | 系统保留 
     低地址  +-----------+
     

### dumpbin工具
段是按照数据的性质而不是按用途来分的，常量与代码就可以合为一段，因为都是只读的。为了更快速地将程序装入内存，可执行文件也会有一定的结构，内部也作了分区，称为节区。VC中有个小工具dumpbin，随便编译一个程序，比如main.exe, 敲入命令：

		dumpbin main.exe

会有类似的输出

		Summary
		        4000 .data
		        1000 .rdata
		        5000 .text

这些`.data .rdata .text`是节区的名称。程序定义的一些常量，比如字符串，多数会放到`.data`里面。当程序被载入时，这些内容会被装到内存的相应位置。要查看节区里面的内容，可以敲入 

		dumpbin main.exe -section:.data -rawdata:bytes > data.txt 

若过之前学过Win32汇编，也有类似`.data .code .const`之类的语句。

栈
-------------
介绍一下栈(stack)。stack是先进后出的。比如叠起来的碟子，只可以在最上面放和最方面取。当放上一个碟子，栈就变高。当取下一个碟子，栈会变低。最后放的会最先取出。放碟子，使碟子升高，这动作叫做 push, 取碟子，使碟子降低，这动作叫做 pop。

stack 这结构用得极其频繁，8086 系列的计算机就有相应的机器指令 push, pop 和相应的寄存器 (e)sp，(e)bp 来支持硬件上的栈。

### 基址+偏移
为得到数据，需要得到它的地址。通常地址都不会直接给出的，会使用基址+偏移的形式。这种形式可以表述为：从某某地方开始，向下或者向上数多少格。所谓基址是一个参考点，偏移是相对参考点而言的。比如 

* 基址为1000，偏移为5，就得到1005
* 基址为1000，偏移为-5，就得到995

基址+偏移的形式用得很广泛，平时接触得最多的是数组。

### push pop
寄存器 ebp 指示栈的底端，通常我们叫它栈底寄存器。

寄存器 esp 指示栈的顶端，我们叫它栈顶寄存器。push 指令会使 esp 减少(减少意味着距离 ebp 更远，就是栈顶升高)，跟着在那个地方放数据。pop 指令将 esp 所指的数取出，跟着 esp 增加(增加意味着距离 ebp 近了，就是栈顶降低)。至于升高或降低多少，就看你的数据有多大了。

push eax

	     EAX      | .....   |      EAX      | .....   |       EAX      | .....   |
	   12345678H  +---------+    12345678H  +---------+     12345678H  +---------+
	              |  02h    |               |  02h    |                |  02h    |
	              +---------+               +---------+                +---------+
	              |  0Dh    |          ESP->|  0Dh    |           ESP->|  78h    |
	              +---------+               +---------+                +---------+
	              |  10h    |               |  10h    |                |  56h    |
	              +---------+               +---------+                +---------+
	              |  F0h    |               |  F0h    |                |  34h    |
	              +---------+               +---------+                +---------+
	              |  06h    |               |  06h    |                |  12h    |
	              +---------+               +---------+                +---------+
	    EBP(ESP)->|  78h    |          EBP->|  78h    |           EBP->|  78h    |
	              +---------+               +---------+                +---------+
	              | ......  |               | ......  |                | ......  |
	              |         |               |         |                |         |
	                 开始                      中间过程                     之后

pop ebx
 
	     EBX      | .....   |      EBX      | .....   |       EBX      | .....   |
	   00000000H  +---------+    12345678H  +---------+     12345678H  +---------+
	              |  02h    |               |  02h    |                |  02h    |
	              +---------+               +---------+                +---------+
	         ESP->|  78h    |          ESP->|  78h    |                |  78h    |
	              +---------+               +---------+                +---------+
	              |  56h    |               |  56h    |                |  56h    |
	              +---------+               +---------+                +---------+
	              |  34h    |               |  34h    |                |  34h    |
	              +---------+               +---------+                +---------+
	              |  12h    |               |  12h    |                |  12h    |
	              +---------+               +---------+                +---------+
	         EBP->|  78h    |          EBP->|  78h    |      EBP(ESP)->|  78h    |
	              +---------+               +---------+                +---------+
	              | ......  |               | ......  |                | ......  |
	              |         |               |         |                |         |
	                 开始                      中间过程                     之后


注
--------
* 写程序时用的地址只是线性地址，从线性地址到物理地址还有个令人抓狂的复杂过程。
* 想了解多点转型符，可以参考 More Effective C++ 条款 2。


[下接变量与常量(3)](/2007/07/09/cpp-const-3.html)

