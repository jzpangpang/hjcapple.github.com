---
title: 保存一条线的数据点
layout: post
published: true
---

## 问题描述
假如一个绘画软件可以让 A、B 两个用户一起绘画，用户 A 画了一条线，需要用户 B 也可以看到，这样就需要将线的数据点信息从 A 发送给 B。或者一个远程教学软件，老师在 PPT 上写字，需要将线条信息传送给学生。

这时一个很现实的问题就是：如何使得线的数据量传输尽量少？这问题相当于如何用尽量少的字节去保存一条线的数据点？

## 数据表示
用鼠标或者手指在屏幕中划过，会产生一系列点。每个点包含坐标数据 x, y。另外假如需要知道绘画的快慢，还需要记录下点的产生时间。

鼠标或者手指按下的时开始计时，第一个点的时间为 0 秒，之后每个点就有一个时间值，鼠标或者手指放开的时候结束计时。下一条线开始的时候，又重新计时。

这样每条线就是独立的了，线条的绘画快慢也就可以通过时间值还原出来。当然了，假如只需要直接显示线条，时间值就可以忽略。

这样一个数据点，就是由下面结构表示：

	struct TimePoint
	{
		float x;
		float y;
		float t;
	};
	
t 为时间值，以秒为单位。一条线由一系列点组成。

	P0, P1, P2, P3, P4 ...... Pn
	
为传输量少应该采用二进制方式，而不是用 Json 之类的字符串方式来存储点信息。

最简单的保存点的二进制方式是：先写入数据点的个数，之后依次写入每个点的 x，y，t。假如不作任何处理，每个点就需要 12 个字节保存。

这样就有点浪费了，下面描述一种更好的数据存储方式。

## 化成整数
浮点数比较难处理，应该先数据转化成整数。将位置信息 x，y 乘以 20 再取整。时间需要的精度比位置的精度要高，将时间值乘以 60 再取整。

20 和 60 这倍数是大致的数值，可以根据实际需求修改。原始的位置信息乘以 20，可以保留小数点后 1 位，对于绘画应用已经足够好了。时间值乘以 60，可以保证刷新率为 60 帧，也足够好了。

## 计算偏移
化成整数之后，每个整数还是需要 4 个字节保存。之后我们计算数据的偏移。先保存第一个点的整数数据，再保存后续各点的偏移：

	P0, P1 - P0, P2 - P1, P3 - P2, P4 - P3, ..... Pn - Pn-1
	
每个点的偏移是各个数据分量的偏移：
	
	P1 - P0 = (x1 - x0, y1 - y0, t1 - t0)
	
偏移量会比原始数据的值要小很多，比如一系列数字：

	1000, 1002, 1004, 1003
	
用偏移量表示就为：

	1000, 2, 4, -1

数字越小，保存时候需要的字节数也会越小。

## 位置数据和时间数据分开保存
位置数据计算偏移之后，可能会出现正数和负数。因为产生第 2 个点的时间肯定会比第 1 个点大，所以时间数据计算偏移之后也一定是正数。另外时间数据用秒为单位，就算乘以 60 取整计算偏移之后，数值也会很小，基本不会大于 10。

这样时间数据就算用 1 字节来保存，也是浪费的，因此时间值可以按照位来保存的。比如最大为 5, 就只需要 3 位保存一个时间值。跟着再顺序读取。

而位置数据会偏大，位置数据也可以按位来保存，但似乎也没有什么必要。可以设计一种变长整数来保存位置数据。

## 变长整数
整数数值有大有小，当很小的时候可以用 1 字节来表示，稍大可以用 2 字节来表示，更大可以用 4 字节来表示。

这里设计了一种变长整数，思路是拿第 1 字节的 bit 0 作判断，如果为 0，就表示只用了 1 字节；如果 bit 0 为 1，就再拿第 1 字节的 bit 1 作判断，这时候 bit 1 为 0，表示用了 2 字节，为 1 就表示用了 4 字节。下面是读取无符号变长整数的 C++ 代码。

	static uint32_t readVariableUint32(const uint8_t*& ptr)
	{
	    uint8_t val = *ptr;
	    if ((val & 0x01) == 0)  // 1 byte
	    {
	        uint8_t v = readUI8(ptr);
	        return (v >> 1);  // 因为有1 bit 于做判断了,需要右移 位
	    }
	    else if ((val & 0x03) == 1)  // 2 bytes
	    {
	        uint16_t v = readUI16(ptr);
	        return (v >> 2);  // 因为有2 bit 于做判断了,需要右移 位
	    }
	    else  // 4 bytes
	    {
	        uint32_t v = readUI32(ptr);
	        return (v >> 2);  // 因为有2 bit 于做判断了,需要右移 位
	    }
	    return 0;
	}
	
有符号变长整数读取时，基本思路跟无符号一样，只是再多占了 1 bit 来 表示正数还是负数。

	static int32_t readVariableInt32(const uint8_t*& ptr)
	{
	    uint8_t flag = *ptr;
	    bool isS = flag & 0x01;
	    flag >>= 1;
	    
	    int32_t v = 0;
	    if ((flag & 0x01) == 0)  // 1 byte
	    {
	        v = readUI8(ptr);
	        v >>= 2;
	    }
	    else if ((flag & 0x03) == 1)  // 2 bytes
	    {
	        v = readUI16(ptr);
	        v >>= 3;
	    }
	    else  // 4 bytes
	    {
	        v = data::readUI32(ptr);
	        v >>= 3;
	    }
	    return isS ? -v : v;
	}
	
写入变长整数的过程是先判断是否可以用 1 字节表示，不可以的话再判断是否可以用 2 字节表示，还不可以就用 4 字节表示。
	
## 位数据

前面已经说过，对于时间值，就算用 1 字节保存也是浪费的。

比如我的数值 为 1，2，3，3，2，1 ，每个数字可以只用 2 bit 来表示。写成二进制就是 01 10 11 11 10 01，这 6 个数字，就可以只用 2 字节来保存。 那怎么知道每个数字用多少 bit 表示呢？所以前面还需要保存一个数字。先规定前面 4 bit 是表示后面的数字用多少 bit 表示，之后就可以跟着一串数值了。比如前面用 2 bit 表示，就为 0010。
这样 1，2，3，3，2，1，就可以表示成一串二进制位。

	0010 | 01 | 10 | 11 | 11 | 10 | 01
	
当需要表示 1，2，3，4，2，1 的时候，需要 3 bit 表示一个数字，因为 4 较大，需要表示为 100，就可以表示为：

	0011 | 001 | 010 | 011 | 100 | 010 | 001

前面 4 位表示后面数值需要的位数。写入过程，就是计算最大的数值可以采用多少位表示，再依次写入各个位。
## 总结
### 位置数据保存
1. 将浮点的数据乘以 20，再取整，将所有数据都化成整数。
2. 跟着保存 P0，保存P1 – P0(P1和P0的偏移量)，P2 – P1，P3 – P2......
3. 算出偏移值之后，再考虑它的大小，用变长整数来存储。

### 时间数据保存

1. 将浮点的数据乘以 60，再取整，将所有数据都化成整数。
2. 跟着保存t1，保存t1 – t0(P1和P0的偏移量)， t2 – t1，t3 – t2......
3. 算出偏移值之后，用位数据来存储。

## 线的存储结构
最后来看一下线的存储。其中的 vi32 就是有符号变长整数。

![save-line.png](/media/images/save-line.png)

分成两部分，一是位置数据，一是时间数据。UB(4)表示读取 4 个 bit 作为整数。之后就可以得到每个时间数据存储所需要的位数，再按位一直读取。

或者也使用位数据来表示坐标点，而不是变长整数，可能数据还会更小一些。

这种存储点的方式，经过测试，大概只有原先大小的 1/3 - 1/4。很多位置数据都可以只用 1 字节表示，小部分是 2 字节，几乎不用 4 字节。

这里再重新强调一下，除了第一个点和第一个时间值是绝对值之外，其它的都是偏移指。读取的时候先读 P0， 跟着读取 offset1， 就可以用 P0 + offset1 还原出 P1，再读取 offset2，就可以用 P1 + offset2，还原出 P2，如此类推。另外这些点数据需要除以 20，以便还原成原始的浮点数，时间值需要除以 60，以便还原成浮点数。

读取的时候需要先累加出整数，再除以 20 或 60。不要先除以 20 或 60 之后再进行累加。不然就会有误差积累。

之后将线数据通过网络发送或者存储到文件的时候，还可以整体做一下 zip 压缩，这样数据量就比较少了。


