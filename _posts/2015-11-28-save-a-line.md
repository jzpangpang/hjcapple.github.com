---
title: 保存一条线的数据点
layout: post
published: true
---

## 问题描述
假如一个绘画软件，可以让 A、B 两个用户一起绘画，用户 A 画了一条线，需要用户 B 也可以看到，这样就需要将线的数据点信息从 A 发送给 B。或者一个远程教学软件，老师远程给学生上课，老师在可以在 PPT 上写字，需要将线条信息传送给学生。

这时一个很现实的问题就是，如何使得线的数据量传输最小？这问题相当于如何用尽量少的字节去保存一条线的数据点。

## 数据表示
线是由一个个数据点组成，用鼠标或者手指在屏幕中划过，会产生一系列点。每个点的坐标数据包含 x, y。另外假如需要知道绘画的快慢，还需要记录下点的产生时间。

鼠标或者手指按下的时开始计时，第一个点的时间为 0 秒，之后每个点就有一个时间值，鼠标或者手指放开的时候结束计时。下一条线开始的时候，又重新计时。

这样每条线就是独立的了，而绘画线的过程快慢也就可以通过时间值还原出来。当然了，假如只需要直接显示线条或者只需要匀速显示，时间值就可以忽略。时间值用秒为单位。

这样一个数据点，就是由下面结构表示：

	struct TimePoint
	{
		float x;
		float y;
		float t;
	};
	
一条线就一系列点组成。

	P0, P1, P2, P3, P4 ...... Pn
	
为传输量小应该采用二进制方式，而不是 Json 之类的字符串方式来存储点信息。

最简单的保存点的方式是，先写入数据点的个数，之后依次写入数据点。假如不作任何处理，每个数据点由 3 个浮点数组成。这样每个数据点就需要 12 个字节保存。这样就有点浪费了。下面描述一下数据压缩的过程。

## 化成整数
浮点数比较难处理，应该先数据转化成整数。将位置信息 x 和 y 乘以 20，再取整，将位置数据化成整数。时间需要的精度比位置的精度要高，将时间值乘以 60，再取整，就将时间值化成整数。

这里 20 和 60 这倍数是大致的数值，原始的位置数据是从屏幕坐标中得到的，乘以 20，就可以保留小数点 1 位了，已经足够了。时间值乘以 60，可以保证刷新率位 60 帧，也足够了。

## 计算偏移
化成整数之后，每个整数还是需要 4 个字节保存，还是没有压缩。之后我们计算数据的偏移。先保存第一个点的整数数据，再保存之后点的偏移：

	P0, P1 - P0, P2 - P1, P3 - P2, P4 - P3, ..... Pn - Pn-1
	
每个点的偏移是各个数据分离的偏移
	
	P1 - P0 = (x1 - x0, y1 - y0, t1 - t0)
	
偏移量会比直接数据的值要小很多，比如一系列数字：

	1000, 1002, 1004, 1003,
	
用偏移量表示就为：

	1000, 2, 4, -1

数字越小，保存时候需要的字节数也会越小。

## 位置数据和时间数据分开保存
位置数据计算偏移之后，可能会出现正数和负数。而因此产生第 2 个点的时间肯定会比第 1 个点大，所以时间数据计算偏移之后也一定是正数。另外时间数据用秒为单位，就算乘以 60 取整计算偏移之后，数值也会很小，基本不会大于 10。

这样时间数据就算用 1 字节来保存，也是浪费的，所以时间值可以按照位来保存的。比如最大为 5, 就只需要 3 位保存一个时间值。跟着再顺序读取。

而位置数据会偏大，偏移值绝大部分也不会超过100。其实位置数据也可以按位来保存，但似乎也没有什么必要。可以设计一种变长整数来保存位置数据。

## 变长整数
整数数值有大有小，当很小的时候可以用 1 字节来表示，稍大可以用 2 字节来表示，更大可以用 4 字节来表示。

这时可以设计一种变长整数，思路是拿第 1 字节的 bit 0 作判断，如果为 0，就表示只用了 1 字节，如 果为 bit 0 为 1，就再拿第 1 字节的 bit 1 作判断，这时候 bit 1 为 0 ,表示用了 2 字节，为 1 就表示用了 4 字节。下面是读取无符号变长整数的 C++ 代码。

	static uint32_t readVariableUint32(const uint8_t*& ptr)
	{
	    uint8_t val = *ptr;
	    if ((val & 0x01) == 0)  // 1 byte
	    {
	        uint8_t v = readUI8(ptr);
	        return (v >> 1);  // 因为有1 bit 于做判断了,需要右移 位
	    }
	    else if ((val & 0x03) == 1)  // 2 bytes
	    {
	        uint16_t v = readUI16(ptr);
	        return (v >> 2);  // 因为有2 bit 于做判断了,需要右移 位
	    }
	    else  // 4 bytes
	    {
	        uint32_t v = readUI32(ptr);
	        return (v >> 2);  // 因为有2 bit 于做判断了,需要右移 位
	    }
	    return 0;
	}
	
有符号变长整数读取时，基本思路跟无符号一样，只是再多占用了 1 bit 来 表示正数还是负数。

	static int32_t readVariableInt32(const uint8_t*& ptr)
	{
	    uint8_t flag = *ptr;
	    bool isS = flag & 0x01;
	    flag >>= 1;
	    
	    int32_t v = 0;
	    if ((flag & 0x01) == 0)  // 1 byte
	    {
	        v = readUI8(ptr);
	        v >>= 2;
	    }
	    else if ((flag & 0x03) == 1)  // 2 bytes
	    {
	        v = readUI16(ptr);
	        v >>= 3;
	    }
	    else  // 4 bytes
	    {
	        v = data::readUI32(ptr);
	        v >>= 3;
	    }
	    return isS ? -v : v;
	}
	
写入变长整数的过程是先判断是否可以用 1 字节表示，不可以的话再判断是否可以用 2 字节表示，还不可以就用 4 字节表示。
	
## 位数据

前面已经说过,对于时间值,就是用 1 字节保存也是浪费的。比如我的数值 为 1,2,3,3,2,1 这样,每个数字可以只用 2 bit 来表示。
写成二进制就是 01 10 11 11 10 01, 这 6 个数字,就可以只用 2 字节来保存。 那怎么知道每个数字用多少 bit 表示呢，所以前面还需要保存一个数字。先规定, 前面4 bit是表示后面的数字用多少bit表示,之后就可以跟着一串数值了。比 如前面用 2 bit 表示,就为 0010,
这样 1,2,3,3,2,1,就可以表示成一串二进制位。 

	0010 | 01 | 10 | 11 | 11 | 10 | 01
	
当需要表示1,2,3,4,2,1的时候,这个时候,需要3 bit表示一个数字,因为 4 较大, 需要表示为 100,就可以表示为

	0011 | 001 | 010 | 011 | 100 | 010 | 001

前面 4 位表示后面数值需要的位数。写入过程，就是计算最大的数值可以采用多少位表示，再依次写入各个位。
## 总结
### 位置数据保存
1. 将浮点的数据乘以 20,再取整，将所有数据都化成整数。
2. 跟着保存 P0, 保存P1 – P0(P1和P0的偏移量), P2 – P1,P3 – P2......
3. 算出偏移值之后,再考虑它的大小,用变长整数来存储。

### 时间数据保存

1. 将浮点的数据乘以 60,再取整,将所有数据都化成整数。
2. 跟着保存t1, 保存t1 – t0(P1和P0的偏移量), t2 – t1, t3 – t2......
3. 算出偏移值之后，用位数据来存储。

## 线的存储结构
到这个时候,我们可以来描述一下线的存储。其中的 vi32 就是有符号变长整数。

![save-line.png](/media/images/save-line.png)

分成两部分,一是位置数据,一是时间数据。UB(4)表示读取 4 个 bit 作为 整数,之后,就可以得到每个时间数据存储所需要的位数,再按位一直读取。

或者也使用位数据来表示坐标点，而不是变长整数，可能数据还会更小一些。

这种存储点的方式，经过测试，大概只有原先大小的 1/3 - 1/4。很多位置数据都可以只用 1 字节表示，小部分是 2 字节，几乎不用 4 字节。

这里再重新强调一下，除了第一个点和第一个时间值是绝对值之外，其它的都是偏移指。读取的时候先读 p0, 跟着读取 offset1, 就可以用 p0 + offset1 还原出 p1, 再读取 offset2, 就可以用 p1 + offset2, 还原出 p2, 如此类推。另外这些点数据需要除以 20，以便还原成原始的浮点数，时间值需要除以 60，以便还原成浮点数。

读取的时候需要先累加出整数，再除以 20 或 60。不要先除以 20 或 60 之后再进行累加。不然就会有误差积累。

之后将线数据通过网络发送或者存储到文件的时候，还可以整体做一下zip压缩，这样数据量就比较少了。


