---
title: 数据结构之动态数组
layout: post
published: true

---

编写应用程序，数组、链表、字典是三种最常用的数据结构。其中数组最为简单，但也有一些地方需要注意。

数组分为静态数组和动态数组。

* 静态数组的大小，在初始化的时候就指定，之后不会进行变化。
* 动态数组的在初始化之后，可以往数组里面添加、删除元素，从而改变大小。

下面的讨论，不特定指明，都是指动态数组。动态数组，在C++中用类std::vector表示。

## 基本讨论

数组的元素，在内存中是连续的，一个挨着一个。因为内存的连续性，只要知道最开始一个元素的位置，并且知道每个元素的大小，就可以快速计算出数组中每个元素的位置。这样数组访问每个元素都十分快速。这点在数据结构的书中称呼，数组支持随机访问。

为保证这种内存连续性，数组有3个缺点。

* 删除数组中间的元素的之后，后面的每个元素都需要向前移动，不然中间就会出现空洞，就不连续了。
* 在数组中间插入某个元素之后，后面的每个元素都需要向后移动，不然就出现元素的覆盖。
* 假如数组的容量满了，比如总容量可以装16个元素，现在已经满了，插入第17个的时候，就需要申请一个更大的内存区域，比如可以装32个元素，将之前的16个元素复制到新的区域，这样就够控件插入第17个了。

可以看到，在数组中间插入或者删除元素是比较慢的，因为需要移动后面的元素，越是靠前，就越慢。而重新分配空间复制旧元素的过程也是比较慢的。

这样，需要更好的使用数组，就需要尽可能的操作靠后的元素，并且可能的减少重新分配空间的次数。

上面说的，很多人都知道，但是实际编程中根本没有注意。下面开始举例。

## 例子1

假如一个2D游戏，在战场上面的所有动画用一个数组放着。当动画开始播放的时候，就插入到数组中，当动画播放完成就从数组中删除。这样就可以用同一个计时器统一更新动画的帧率，方便实现加速、减速、暂停。

假如有动画 

	A B C D E
	
当动画 F 开始播放之后，就变成

	A B C D E F

这时后，动画 B 播放完成。较为简单天真的方式是直接删除 B, 变成

	A C D E F
	
但是，这样就引起B后面的动画向前移动。B越靠前，动画越多，删除时候就越慢。更好的方式是，先将最后面的动画复制到需要删除的位置，再删除最后的动画

	复制最后: A F C D E F
	删除最后: A F C D E

这样无论有之前有多少个动画，删除时候也一样快。但这样就打乱了数组的原先顺序。有很多应用场合，数组的顺序其实是没有关系的，用数组放着某样东西，只不过是想按照相同的方式统一处理。

比如这里的动画管理，还有定时器管理，一些粒子系统，物理系统，顺序都没有关系，就可以利用数组的特性，快速删除。

## 例子2

假如有个1000个key-value对的字典，我需要取得字典中的所有key，并用数组返回。这问题很简单，用C++可以写成：

{% highlight c %}
std::vector<int> getAllKeys(const std::map<int, std::string>& map)
{
    std::vector<int> v;
    for (auto& iter : map)
    {
        v.push_back(iter.first);
    }
    return v;
}
{% endhighlight %}

上面的代码很常见，绝大多数的C++程序员都写过类似这样的代码。上面代码很正确，似乎无啥问题，但问题是速度慢。动态数组容量不够的时候需要重新分配空间，这种重分配的过程隐藏在实现内部。当字典为1000的时候，假如按照最常见的每次容量翻倍的方式，重分配的过程出现在大小为
	
	1 2 4 8 16 32 64 128 256 512 1024
	
的时候，就重新分配复制了11次。需要在最开始的时候就指定一个容量值，修改成

{% highlight c %}
std::vector<int> getAllKeys(const std::map<int, std::string>& map)
{
    std::vector<int> v;
    v.reserve(map.size());
    for (auto& iter : map)
    {
        v.push_back(iter.first);
    }
    return v;
}
{% endhighlight %}
	
这样一开始就分配一个正确的容量，修改起来也简单，速度会提升不小。很多使用数组的场合，都是可以大致估算出容量的，但很多人没有注意这个。不少的数据结构，都有重新分配空间的过程，这些数据结构类通常也会提供一个指明容量的方法。

## 再讨论内存连续性

数组元素在内存中连续，排列得很紧凑，它们的位置已经隐含了顺序。存储相同的数据量，数组的空间利用率是最高的。链表中的结构需要存储一对指向前后的指针，二叉树树也需要存储一对指向左右孩子的指针，并且链表和二叉树的每个节点不连续，需要单独分配，这样还需要一存储一些分配信息以便被正确地释放。哈希表也需要预留一些空间，来避免过于频繁的碰撞冲突。

访问4个字节的内存，机器并非单纯取出4个字节，而是将附近的内存也一起取进去，放在机器的缓冲中。当访问数组元素1的时候，元素2很可能已经预先被缓冲起来了。数组的从头向后遍历的速度是很快的。也需要可能的保持按顺序扫描，不要跳来跳去。

### 例子

假如一个二维矩阵

	A B C D E F
	1 2 3 4 5 6
	a b c d e f
	
假设按照行顺序排列，按照数组存储，在内存中被表示为
	
	A B C D E F 1 2 3 4 5 6 a b c d e f
	
这样当按照行方式扫描，处理起来就很快。这道理很多人都会知道，但有时不注意，比如下面的代码

{% highlight c %}
for (int x = 0; x < row_size; x++)
{
    for (int y = 0; y < column_size, y++)
    {
        do_something(matrix[x][y]);
    }
} 
{% endhighlight %}
    
似乎没有什么问题。但这样的代码是按照列方式扫描的。处理顺序为

	A 1 a B 2 b C 3 c D 4 d E 5 e F 6 f
	
就会产生访问内存时候的跳来跳去。可以修正为

{% highlight c %}
for (int y = 0; y < column_size, y++)
{
    for (int x = 0; x < row_size; x++)
    {
        do_something(matrix[x][y]);
    }
}
{% endhighlight %}
    
这个修正只是简单的换了循环的顺序。

 

