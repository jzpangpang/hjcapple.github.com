---
title: 理解C++ — 变量与常量(3)
layout: post
published: false

---
 [上接变量与常量(1)](/2007/07/07/cpp-const-1.html)
 
为解决前面的遗留问题，需要分析代码编译后的汇编输出, (1)(2)其实都是为了分析打基础的。所用的编译器为VC++6.0, 假设我们的文件为main.cpp。敲入编译命令 cl -GX -nologo -FAs main.cpp。-FAs选项可以输出汇编代码，之后目录处会多了main.asm。编译时不作优化处理, 以免使分析更复杂。也可以建立个控制台工程，Project->setting调出设置对话框, C/C++标签, Category选择Listing Files, Listing file type选择Assembly with Source Code。其实刚学C++的时候，拿个文本编辑器写代码，再敲命令编译会更方便，文本编辑器可以考虑一下vim。假如这系列帖子可以写下去，很可能会有很多汇编分析的，要有点心理准备，其实也不会很难的，来来去去都是那几条指令, push, pop用得很多，之前也已经解释过了。也可以选择自己喜欢的编译器, 不过那样汇编输出会有些不同。我知道VC++6.0不是很合标准，不过还没有牵涉到template就没有多大关系了，VC++.net之类大笨重了，我的机器烂，会很慢。gcc的汇编输出跟学汇编时养成的习惯正好相反，看着别扭。所以选择6.0。

开始的汇编分析会讲到比较详细，后面会较简略。看这个例子
=========================
#include <stdio.h>

const int a = 3;
int b = 1024 * a;

int main()
{
    const int a = 2;
    int b = 1024 * a;

    const int* pa_g = &::a;
    const int* pa_l = &a;

    //*(const_cast<int*>(pa_g)) = 100;
    printf("%d\n", *pa_g);
    printf("%d\n", ::a);
    printf("%d\n", ::b);

    *(const_cast<int*>(pa_l)) = 100;
    printf("%d\n", *pa_l);
    printf("%d\n", a);
    printf("%d\n", b);

    return 0;
}
========================================
先不运行，猜一猜结果会是什么。运行结果为3 3 3072 100 2 2048。猜对没有? 我猜的是 3 3 3072 100 100 2048。结果令我很吃惊，我怎么也想不明白printf("%d\n", *pa_l)和printf("%d\n", a)为什么会不同。还有*(const_cast<int*>(pa_g)) = 100;编译的时候是没有问题的，运行时就会出错。看汇编输出之后，一切都明白了。(假设已经得到汇编输出)

========================================
CONST    SEGMENT
_a    DD    03H
CONST    ENDS
_DATA    SEGMENT
?b@@3HA    DD    0c00H                    
_DATA    ENDS

这就是全局变量a和b的内存分配方式。那些SEGMENT ENDS指定数据分到什么节区，还记得之前说的.data .rdata .text吗? const中的数据会放到.rdata, 装入内存就是只读的数据。_DATA中的数据会放到.data 装入内存就是成了全局数据了，原则上static定义的也是全局数据。那为什么b会变成?b@@3HA这古怪的样子呢? 这主要是为了解决重名问题。程序中可以重名，不过编译连接的时候就不可以，名字要唯一的。这样就需要有一套规则来将程序中的名字转换到一个唯一的名字。每个编译器都有自己的规则。以前我无聊的时候看过每个符号代表什么意思，不过很多都搞不明白，没有记错的话, H是代表int类型, 内置的内型都是自己的代表字母，不过这些不用深究。要是用gcc, 还有个工具叫c++filt, 你敲这些转换后符号进去，会输出程序定义时的符号。这时候可以看出，全局变量a放到CONST段，只读；全局变量b放到_DATA段，可以读写。

现在可以解释*(const_cast<int*>(pa_g)) = 100; 运行时候为什么会出错了? pa_g指向::a(::a代表全局变量a, 为了和main函数里面的a作区别), 而::a是只读的，意图修改::a的值，当然会出错了，还记得之前说的段保护吗?

再看看::a,可以看到它的值为03H, 也就是3, ::b，值为0c00H, 也就是3072。编译成可执行文件之后，::a和::b会在文件的节区中存储着，跟着再装入内存，所以::a和::b在程序还没有执行之前就有了初始值。::b的初始值为3075，说明编译的时候已经计算了1024 * a。要是程序中定义了常量，常量出现的地方会直接被它的数值所替代。那么式子就变成1024 * 3，完全可以在编译时期确定下来。式子中有常量，编译时候直接计算了结果，这叫做常量折叠。很复杂的式子在编译时期也可以直接计算出来，比如(a*a*a)+(a/a)+1024-a; 所以写程序的时候，不要那么笨自己去手工算了，没有意义的，还使代码更难明白。比如想分配9k内存，直接写成malloc(9*1024)就可以了。

=========================================
_DATA    SEGMENT
$SG532    DB    '%d', 0aH, 00H
$SG533    DB    '%d', 0aH, 00H
$SG534    DB    '%d', 0aH, 00H
$SG536    DB    '%d', 0aH, 00H
$SG537    DB    '%d', 0aH, 00H
$SG538    DB    '%d', 0aH, 00H
_DATA    ENDS

可以看出，程序用到的字符串也放到_DATA中，0aH是ASCII码，表示回车符，字符串以'\0'结尾。'\0'起来就是00h。这是没有优化的结果，优化之后，相同内容的字符串很可能会合并为一个。
=======================================

下面转入_TEXT段，通常这里会放代码。看看main函数里面a,b,pa_g,pa_l的定义
_a$ = -4
_b$ = -12
_pa_g$ = -16
_pa_l$ = -8
为什么会这样的呢? 不要着急，慢慢看下去。

===========================
push    ebp
mov    ebp, esp
sub    esp, 16
这几句是进入函数时候做的准备，是调整堆栈，给局部变量分配空间。sub esp 16 给a,b,pa_g,pa_l分配空间,占用16个字节。这问题先放开。

============================
mov    DWORD PTR _a$[ebp], 2

mov    DWORD PTR _b$[ebp], 2048        

mov    DWORD PTR _pa_g$[ebp], OFFSET FLAT:_a

lea    eax, DWORD PTR _a$[ebp]
mov    DWORD PTR _pa_l$[ebp], eax

看看a,b,pa_g,pa_l的赋值。上面已经知道 _a$ = -4， 这其实就是个偏移，ebp为参考点，向上数4个基本单元，这个内存范围就分给了变量a, ebp-4就是a的起始地址。之前说过类型的意义，其中一个就是可以确定变量的大小，同样dword ptr就表示这是一个dword类型，dword是双字，也就是占用4个字节。Masm汇编中用中括号表示地址里面的值，所以wrod ptr [ebp-4]就表示变量a的值。[ebp-4]可以写成-4[bep], 而 _a$ = -4, 因此就知道mov dword ptr _a$[ebp], 2 表示将2赋给a, 就是a=2。

同样mov    DWORD PTR _b$[ebp], 2048, 是给b赋值。2048是编译的时候已经计算了a*1024,为常量折叠。

可以看出
const int a = 2;
int b = a * 1024;
a有没有const来修饰，从汇编输出是看不出来的。const只不过是编译时候定的约束，真正编译出来的代码其实是没有分别的。

OFFSET FLAT:_a是全局变量a的偏移, 将这偏移放到pa_g中，pa_g就指向了全局的a, pa_g就为一指针。所谓指针，放的就是地址，更准确的是一个偏移, 这个偏移是以数据段起始地址为参考点，这里偏移当成数据的地址就可以了。

lea    eax, DWORD PTR _a$[ebp]是取得局部a的地址，跟着放入pa_l中，所以pa_l指向局部的a, pa_l也为一指针。

那为什么取全局变量a的地址用offset, 而取局部变量a的地址用lea的呢? 这是因为全局a在程序运行时候，地址就已经确定了。局部a在栈中分配内存，地址在程序执行的时候才确定。offset只可以取静态的地址，lea却可以取动态的地址。这是offset 和lea的分别。学汇编的时候，这个问题也很多人问的。

=================================
mov    ecx, DWORD PTR _pa_g$[ebp]
mov    edx, DWORD PTR [ecx]
push    edx
push    OFFSET FLAT:$SG532
call    _printf
add    esp, 8

这是语句printf("%d\n", *pa_g);的汇编输出，首先将pa_g的值取出，放到ecx中，pa_g的值是个地址。再根据ecx这个地址，取出地址所指内存的数据，放到edx, 这个就是*pa_g的含义。先从pa_g得到地址，再根据地址取数据。push edx将取到的数据压栈，再将"%d\n"的地址压栈，再调用函数printf。之后add esp 8语句将栈恢复平衡。函数的调用和返回，以后有机会再写篇帖子，现在不多说。

=================================
之后的函数调用过程都差不多。再看
mov    ecx, DWORD PTR _pa_l$[ebp]
mov    DWORD PTR [ecx], 100
先将pa_l的值取出，放到ecx, 注意这是个地址，下一个语句就这地址所值内存的值,也就是局部变量a的值变为100。这个时候a=100。从这里可以看出，用const修饰不一定就不能改变。不过改变的时候用麻烦一点，需要指针或者引用，间接的改变。

===========================
好啦，因为a的值已经改变，自然printf("%d\n", *pa_l);会输出100。那么为什么printf("%d\n", a); 却还是输出2的呢? 那不是矛盾了吗?
前面我们说过, 编译时候遇到常量，就用常量的数值来代替。因为a定义为常量, 所以printf("%d\n", a);直接变为printf("%d\n", 2);看看编译结果
push    2
push    OFFSET FLAT:$SG537
call    _printf
add    esp, 8
直接传递参数2的，所以这个时候a变不变，跟printf("%d\n", a)都没有关系了。再看看printf("%d\n", b);b不是常量，被编译成
mov    ecx, DWORD PTR _b$[ebp]
push    ecx
push    OFFSET FLAT:$SG538
call    _printf
add    esp, 8
需要先取出b的值，再传递参数。这是常量和变量很大的不同，不过这个不同发生在编译时候。当执行的时候，已经没有什么区别了，从编译出来的代码基本上不能区分变量和常量了。而局部的常量和全局常量的不同，在于全局常量被分到只读段，局部常量还是在栈段。局部常量的所谓不可变，是编译器在编译的时候保证的，而不是在程序执行的时候。

================================
到这里，例子已经分析得差不多了，还有些汇编输出都不太重要，提一下EXTRN    _printf:NEAR是引入外部符号。好好看看这个例子，希望大家有所收获。关于这个变量与常量这个主题，也快完了，还有最后一篇。



