---
title: 使用 C++ 输出 C 代码
layout: post
published: true
---

## 问题缘由
移动开发中，相同图片内容需要准备多个尺寸。比如 iOS 开发，就需要准备 1x, 2x, 3x 三种图片。

为减少资源大小并保证图片清晰，可以采用矢量图来开发 App, 比如 svg。但使用矢量图也有问题，需要在 App 中嵌入解析库，并在运行时候再进行解析渲染。这样就产生代码依赖，并拖慢程序的运行速度。

可以预先分析出矢量图片产生绘图代码。之后将产生的代码加入到工程中编译运行，就省下运行时分析矢量图的过程，并没有代码依赖。

通过分析 swf 格式的矢量图，转换后输出 svg 或者是 iOS 上的 Quartz 绘图代码。这类似 PaintCode，但因为分析 swf，就可以利用 Flash 来画图。我没有本事也没有兴趣去写一个绘图软件。

定义中间层的数据结构作为桥接。一个是矢量前端，将 swf, svg，AI 等矢量数据分析出来，转成中间层。再定义一个Graphics 接口作为后端，不同平台实现这个接口，就可以将矢量图输出或者显示到不同地方。

![swf-graphics.png](/media/images/swf-graphics.png)

## 问题
矢量图解析在这里不讨论，现在只关注当中一个小问题。Quartz 绘图代码是 C 代码，这样一个很实际，不是乱编的问题就是。怎样方便使用 C++ 去输出 C 代码？

用 C++ 操作字符串不是很方便，而整个框架是用 C++ 编写的，为了这一小小的输出去切换其它语言更不值得。

举个例子，需要编写 `genCode`, 使得下面程序

	typedef struct
	{
	    float red;
	    float green;
	    float blue;
	    float alpha;
	} Color;
	
	typedef struct
	{
	    Color color;
	    float location;
	} GradientStop;
	
	static std::string genCode(const std::string& func_name, const std::vector<GradientStop>& stops);
	
	int main(int argc, const char* argv[])
	{
	    GradientStop array[] = {
	        1, 0, 0, 1, 0,
	        1, 1, 0, 1, 0.5,
	        1, 0, 0, 1, 1,
	    };
	    
	    std::vector<GradientStop> stops(std::begin(array), std::end(array));
	    std::cout << genCode("create_gradient_0", stops);
	    return 0;
	}
	
运行时输出：

	static CGGradientRef create_gradient_0(const TKColorTransform* colorTrans)
	{
	    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
	    CGFloat colors[12] = {
	        1, 0, 0, 1,
	        1, 1, 0, 1,
	        1, 0, 0, 1,
	    };
	    TKColorApplyColorTransform(colors + 0, colorTrans);
	    TKColorApplyColorTransform(colors + 4, colorTrans);
	    TKColorApplyColorTransform(colors + 8, colorTrans);
	    CGFloat locations[3] = {
	        0,
	        0.5,
	        1,
	    };
	    CGGradientRef result = CGGradientCreateWithColorComponents(colorSpace, colors, locations, 3);
	    CGColorSpaceRelease(colorSpace);
	    return result;
	}
	
上面程序输出了创建渐变的 C 代码。这里需要一个循环，将传入的std::vector转换成 colors 数组和 locations 数组，另外还需要注意输出代码的缩进美观。

## 代码输出方案
我所知道的代码输出大致有三种方案。网页，信件之类也可以看成是代码输出。

* 模板替换，比如邮件：
	
		$name$:
		欢迎注册使用我们的产品。
						$date$
						CEO: XXXXX
						
	之后将 $name$ 和 $date$ 替换成具体的字符。

* 模板中嵌入代码（或者说代码中嵌入模板），比如
	
		<ul>
		#foreach ($book in $books)
			<li>$book.name</lib>
		#end
		</ul>
	
* 直接写字符串。

		std::string result;
		result += "static CGGradientRef ";
		result += funname;
		result += "(const TKColorTransform* colorTrans)"
		result += "\n";
		
输出方案界限并非十分清晰，实际中可以混合使用。

	char buf[256];
	sprintf("static CGGradientRef %s(const TKColorTransform* colorTrans);\n", funname);
	
这种格式字符串的代码，也可以看成是模板。

## 问题解决过程
最开始，我没有怎么多想，就使用 boost::format 库，用写字符串的方式输出。但总有几个烦人的地方：

* 代码的缩进和换行。
* 函数定义和调用。
* 数组初始化。
* 修改输出的变量名。

比如初始代码为
	
	stream << boost::format("CGContextMoveTo(context, %1%, %2%);\n") % x % y;
	
后面发觉需要缩进，就修改成：

	stream << format_str(1, "CGContextMoveTo(context, %1%, %2%);\n", x, y);
	
这里1为缩进等级，为 1 表示向右缩进4个空格。接着发觉 context 这个名字有点长，想改成 ctx, 问题是代码输出中包含大量的context输出。这样为以后方便修改，就需要将这个名字抽离出来出来。就变成：

	const char* kContext = "ctx";
	stream << format_str(1, "CGContextMoveTo(context, %1%, %2%, %3%);\n", kContext, x, y);
	
再比如，我原来需要输出的 C 代码为：
	
    CGGradientRef gradient = create_gradient_0(colorTrans);
    CGContextDrawLinearGradient(ctx, gradient, xxxxxx);
    CGGradientRelease(gradient);
    
之后因为有多个渐变，gradient 的名字就冲突了。就需要改成输出：

	{
	    CGGradientRef gradient = create_gradient_0(colorTrans);
	    CGContextDrawLinearGradient(ctx, gradient, xxxxxx);
	    CGGradientRelease(gradient);
	}
这样又需要修改缩进了。将 `format_str(1, xxxx` 修改成 `format_st(2, xxxxx`

就是这样的反复调整，让我比较厌烦。当然我可以蛮干堆苦力去调整。而依照以前的经验，写代码时候假如需要反复纠结在某细节，需要反复注意，那个地方肯定有问题。就算我现在堆苦力修改好输出，还是会留下隐患。某段代码连看也不想再看，那段代码就会烂掉。

之后就抽身出来，先编写好一个专门用来输出 C 代码的库，再处理具体的代码输出。

总是烦人的地方，就是库需要解决的。烦人的地方应该一次解决，以后就不用再烦了。最终生成的 C 代码是很简单，没有 if whilte 等语句的，在生成的时候已经被展开了。库只需要让下面的语句更容易就行了。

* 缩进和换号。
* 函数定义。
* 函数调用。
* 数组定义和初始化。

这个所谓的库其实只有一个类 C_Coder。
	
## C_Coder 的简单使用
C_Coder 在 [GitHub](https://github.com/hjcapple/c_coder) 中。C_Coder 使用链式语法。使用 getCode() 取得最终输出。其实 C_Coder 还比较简陋，但对于我自己的需求，已经够用了。

	str::C_Coder coder;
	xxxx
	std::cout << coder.getCode();

### 代码块 begin、end

	coder
	.begin()
	.end();
	
输出
	
	{
	}

begin() 和 end() 之间的所有代码自动缩进。

### 函数调用 call
    coder
    .begin()
    .call("CGContextMoveToPoint")("context", 10, 20)
    .end();
    
输出

	{
    	CGContextMoveToPoint(context, 10, 20);
	}
	
### 函数定义 deffun

	coder
    .deffun("int", "max2", [&](auto& args) {
        args("int", "a")("int", "b");
    })
    .begin()
    .end();
    
输出
	
	int max2(int a, int b)
	{
	}
	
### 数组定义和初始化 defarray

    coder
    .defarray("int", "array", [](auto& make) { make
        (1, 2, 3, 4, 5)
        (6, 7, 8, 9, 10);
    });
	
输出

	int array[10] = {
	    1, 2, 3, 4, 5,
	    6, 7, 8, 9, 10,
	};
	
### 换行 br

	 coder
    .deffun("int", "max2", [&](auto& args) {
        args("int", "a")("int", "b");
    })
    .begin()
    .br("return a > b ? a : b;")
    .end();
    
输出

	int max2(int a, int b)
	{
	    return a > b ? a : b;
	}
	
### 格式化
另外 str 是输出字符串，但不换行。str 和 br 支持 boost::format（使用了boost::format) 的格式化语句，比如

	 coder
    .br("sin(%1%);", 30);
    
输出

	sin(30);
	
	
最后使用 C_Coder 来编写最开始提出的 genCode，为。

	static std::string genCode(const std::string& func_name, const std::vector<GradientStop>& stops)
	{
	    str::C_Coder coder;
	    coder.str("static ").deffun("CGGradientRef", func_name, [&](auto& args) {
	        args("const TKColorTransform*", "colorTrans");
	    })
	    .begin()
	    .defvar("CGColorSpaceRef", "colorSpace").assign().call("CGColorSpaceCreateDeviceRGB")()
	    .defarray("CGFloat", "colors", [&](auto& mark) {
	        for (auto& stop : stops)
	        {
	            auto& color = stop.color;
	            mark(color.red, color.green, color.blue, color.alpha);
	        }
	    });
	    
	    for (size_t i = 0; i < stops.size(); i++)
	    {
	        auto arg0 = str::format_str("%1% + %2%", "colors", i * 4);
	        coder.call("TKColorApplyColorTransform")(arg0, "colorTrans");
	    }
	    
	    coder.defarray("CGFloat", "locations", [&](auto& mark) {
	        for (auto& stop : stops)
	        {
	            mark(stop.location);
	        }
	    });
	    
	    coder
	    .str("CGGradientRef result = ")
	    .call("CGGradientCreateWithColorComponents")("colorSpace", "colors", "locations", stops.size())
	    .call("CGColorSpaceRelease")("colorSpace")
	    .br("return result;")
	    .end()
	    .br();
	    return coder.getCode();
	}
	
