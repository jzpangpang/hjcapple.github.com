---
title: C/C++ 中的位运算
layout: post
published: true

---
概述
----------
C/C++ 支持低阶的位运算，教科书也会说这部分内容，只是比较简略。相信很多人只知道位运算的定义，而不知道具体应该用在什么地方。

此文主要涉及的位运算用于操作标志值。

标记
----------
一个事物、一个系统、或一个程序可能会出现一种或者几种状态。为了在不同的状态下，作出不同的行为，可以设立一些标志值，再根据标志值来做判断。

### 文件流标记
如 C++ 的文件流，可以设定标志值

* ios::app
* ios::ate
* ios::binary
* ios::in
* ios::out
* ios::trunc

之后可以用 | 将标记值组合起来。原则上也可以将这些标志值定义为 bool 类型，不过这样做，标志值一多，会很浪费空间。

### 一个 int，多个标记位
定义一个整型数值

		unsigned int flags;
现在的系统，flags 应是 32 位, 用 0，1，2，3 .... 31 将位进行编号（程序员大多是从 0 开始数数）。可以进行这样的判断, 当位 0 取 1 时，表示用读方式打开文件，当位 1 取 1 时，表示用写方式打开文件，当位 2 取 1 时，用二进制方式打开文件等等。

flags 有 32 位，最多也就可以同时设置 32 个不同的状态值。对比同时使用多个 bool，大大省了空间。另外使用位操作，可以方便将标志值组合起来。


标志值设置
---------
下面看看到底怎么操作这些标志值。

### ios 定义
设想 C++ 的类 ios 这样定义, 其实没有这个类，只有 ios_basic 类，`typedef basic_ios<char> ios;`

		class ios
		{
		public:
		    enum {    app = 0x0001, ate = 0x0002, binary = 0x0004,
		        in = 0x0008,  out = 0x0010, trunc = 0x0020 };
		    ....
		private:
		    unsigned int flags;
		};

注意上面 enum 语句中，每一个数值转化成二进制，只有 1 位是 1，其余是 0，这点很重要。

### 或运算
现在将 flags 相应的位设置为 1, 可以这样做 

		flags |= binary
这个等于

		flags = flags | binary
		
binary 只有 1 位是 1，其余是 0，因为

* 0 | 1 = 1
* 0 | 0 = 0

这样0对应的位是不变的。而

* 1 | 1 = 1
* 1 | 0 = 1

1 对应的位不论原来是什么状态，都一定为 1。

### 位组合
如果想要将几个位都设置为 1，可以这样做 

		flags |= (app | ate | binary)

因为每个 enum 常数各有一位为 1, 与运算之后就有 3 位为 1，就如上面的分析，就可以将那 3 位都设置为 1, 其余位不变。这个就是标志可以组合起来用的原因。

也可以用 + 组合起来，原因在于(下面的数字是 2 进制)

		0001 + 0010 + 0100 = 0111

跟与运算结果一样。不过不提倡用 +, 考虑

		(app | ate | binary)

要是我不小心写多了个标志值，

		(app | ate | ate | binary)

结果还是正确的，如果用 + 的话，就会产生进位，结果就会错误。通常我们不知道原先已经组合了多少个标志值了，用或运算会安全。

### 与运算
现在将 flags 对应的位设置为 0, 可以这样做 

		flags &= ~binary
相当于 

		flags = flags & (~binary)

取反之后，~binary，就只有 1 位是 0 ，其余是 1 。又因为

* 0 & 1 = 0
* 0 & 0 = 0
* 1 & 0 = 0
* 1 & 1 = 1

做与运算之后，1 对应的位并不会改变，0 对应的为不管原来是 1 是 0 ，都肯定为 0 ，这样就将对应的位设置了0。同样同时设置几个标志位可以这样做

		flags &= ~(app | ate | binary)

### 异或
现在将 flags 对应的位，如果是 1 就变成 0，如果是 0 就变成 1 ，可以这样做 

		flags ^= app

同时设置几个标志位可以写成

		 flags ^= (app | ate | binary)
 
不再做分析了，不然就太罗嗦了。

将Ascii码的大小写转换
----------
不过也给大家一个例子，你查查 Ascii 表，会发现对应的大小写字母是相差倒数第 6 位，可以用这样的函数统一的将大写变成小写，小写变成大写。

		void xchgUppLow(std::string& letters)
		{
		    const unsigned int mask = (1 << 5);
		    for (size_t i = 0; i < letters.size(); i++)
		    {
		        letters[i] ^= mask;
		    }
		}

前提是输入的 std::string 一定要全是字母, 而要想是操作字母，可以在原来基础上加个判断。

位标记判断
----------
好啦，上面已经可以设置 flags 的对应位值了，要是判断呢？可以这样写 

		if (flags & app)

这样可以判断对应的位值是否为1, 因为C\C++语言中非0就真。app只有一位是1，其余是0，如果, flags的对应位也是0，在与操作下就得到结果0，反之非0，这样就可以判断标志位了。

bitset
------------
上面关于标志值的操作就介绍完毕。其实在C++中已经有了个bitset了，没有必要去自己进行低阶的位运算，上面的四个操作在bitset中分别叫做set, reset, flip, test。不过在C中，这样的代码还很常见, 反正知道多点也没有坏处。

windows API的例子
----------
用 windows API 编程，你也经常会碰到这样的标志值，要互相组合，可以用|, 也可以用+(只是建议用|，理由上面说了). 它的标志值也是这样定义的，不过用#define

		#define WS_BORDER    0x0001
		#define WS_CAPTION   0x0002

当初我就是想不明白为什么可以用|或者用+来组合判断，现在知道了。

(注：上面出现的数字是我自己作的，到底实际怎么定义其实没有关系，只要保证只有一位是1，其余是0就可以的了. 因为编程的时候用的是常量值，没有人这样笨去直接用数值的)

位运算的其它用法
------------
位运算还有很多用处。比如移位相当于乘除 2 的幂数(不过通常编译器也将乘除2的幂数优化成汇编的移位指令，所以没有必要不要这样卖弄了。汇编的移位指令有两组，分别针对有符号和无符号的, (我猜想在C\C++的同一移位运算针对有符号整数和无符号整数的不同，会根据情况编译成不同的汇编移位指令，不过没有去证实), 

### 构造掩码
其实移位更用得多的地方是去构造一个掩码, 比如上面的

		mask = (1 << 5);

### 求余数
还有 & 运算，有时候可以用来求余数。比如 

		value & (1 << 4 - 1);

这相当于将 value 的高位全变成 0 了，效果等于 `value % 8`。

### 简单加密
还有值得一提的是 ^ 运算，它有个很特殊的性质。比如 

		A ^= B
变成另一个数，跟着再执行

		A ^= B

又变回原来的数了，不信你可以列真值表或者化简逻辑式看看。就因为这个性质，^有很多用途。比如加密，你将原文看成A, 用同一个B异或一次，就相当于加密，跟着在用B异或一次，相当于解密。不过这样是很容易破解就是了。要是一个B不够，还可以加个C, 比如

		A ^= B, A ^= C	// 加密
		A ^= C, A ^= B	// 解密

恢复原状。

### 交换
下面一个小程序，用异或交换两个数字。

		int x = 3;
		int y = 4;
		
		x ^= y;
		y ^= x;
		x ^= y;

其实和止交换数字，连交换对象也可以的

		template <typename T>
		void swap(T& obj1, T& obj2)
		{
		    const int sizeOfObj = sizeof(T);
		    char* pt1 = (char*)&obj1;
		    char* pt2 = (char*)&obj2;
		
		    for (size_t i = 0; i < sizeOfObj; i++)
		    {
		        pt1[i] ^= pt2[i];
		        pt2[i] ^= pt1[i];
		        pt1[i] ^= pt2[i];
		    }
		}

###光栅操作
还有异或操作还可以用在图象的光栅操作。我们知道，颜色也是用二进制来表示的，对颜色进行不同的位运算，就可以得到不同的光栅。因为异或的特殊性质，我们用异或操作的光栅画了副图，跟着再在原来的地方画一次，那副图就刷除了。这样可以用来显示动画而不用保存原来的画像信息。比如背景色是白色的，也就是全1，作

		A ^ 1 = A

所以用画刷画一次是画了设定的颜色，再画一次就恢复。

两种颜色相交的时候，颜色也会作异或叠加，自动产生一种新的颜色了，


输出对象位值
------------
在最后再给大家一段代码，是用来看看对象在内存中的位值的。可以看看。

			std::string bitsOfUChar(unsigned char c)
			{
			    const int numOfBitsInUChar = 8;
			    unsigned int mask = (1 << 7);
			    std::string result(8, '0');
			
			    for (size_t i = 0; i < numOfBitsInUChar; i++)
			    {
			        if (mask & c)
			        {
			            result[i] = '1';
			        }
			
			        mask >>= 1;
			    }
			    return result;
			}
			
			template <typename T>
			std::string bitsInMemory(const T& obj)
			{
			    int sizeOfObj = sizeof(obj);
			    unsigned char* pt = (unsigned char*)&obj;
			    std::string result;
			
			    for (size_t i = 0; i < sizeOfObj; i++)
			    {
			        result += bitsOfUChar(pt[i]);
			        result += ' ';
			    }
			
			    return result;
			}

比如`bitsInMemory(12)`，会输出

		00001100 00000000 00000000 00000000
		
我就知道我自己的机器是小尾顺序的了，并且 int 有 32 位。

